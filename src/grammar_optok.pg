# $Id$

grammar Perl6::Grammar;


## terms
proto 'term:' is precedence('22=')
    is parsed(&term)
    is pastrule('past_term') { ... }

## the circumfix: and postcircumfix: entries here aren't
## actually used for parsing ("expect(0)") -- we're just
## setting traits needed for other stages in the
## translation.  (The parsing actually takes place in
## the <term> subrule.)
proto 'circumfix:( )' is equiv('term:')
    is post('set')
    is expect(0)
    { ... }

proto 'postcircumfix:( )' is equiv('term:') 
    is pasttype('call')
    is past('call')
    is expect(0)
    { ... }

## autoincrement
proto 'postfix:++' is precedence('20=') { ... }
proto 'postfix:--' is equiv('postfix:++') { ... }
proto 'prefix:++' is equiv('postfix:++') { ... }
proto 'prefix:--' is equiv('postfix:++') { ... }


## exponentiation
proto 'infix:**' is precedence('19=') { ... }

## symbolic unary
proto 'prefix:!' is precedence('18=') { ... }
proto 'prefix:+' is equiv('prefix:!') { ... }

proto 'prefix:-' is equiv('prefix:!')
    is post('neg')
    { ... }

proto 'prefix:~' is equiv('prefix:!') { ... }
proto 'prefix:?' is equiv('prefix:!') { ... }
proto 'prefix:=' is equiv('prefix:!') { ... }
proto 'prefix:*' is equiv('prefix:!') { ... }
proto 'prefix:**' is equiv('prefix:!') { ... }
proto 'prefix:~^' is equiv('prefix:!') { ... }

proto 'prefix:+^' is equiv('prefix:!') 
    is post('bnot')
    { ... }

proto 'prefix:?^' is equiv('prefix:!') { ... }
proto 'prefix:^' is equiv('prefix:!') { ... }


## multiplicative
proto 'infix:*' is precedence('17=')
    is post('mul')
    is pirop('n_mul')
    { ... }

proto 'infix:/' is equiv('infix:*')
    is post('div')
    { ... }

proto 'infix:%' is equiv('infix:*')
    is post('mod')
    { ... }

proto 'infix:x' is equiv('infix:*')
    is post('repeat')
    { ... }

proto 'infix:xx' is equiv('infix:*') { ... }

proto 'infix:+&' is equiv('infix:*')
    is post('band')
    { ... }

proto 'infix:+<' is equiv('infix:*')
    is post('shl')
    { ... }

proto 'infix:+>' is equiv('infix:*')
    is post('shr')
    { ... }

proto 'infix:~&' is equiv('infix:*')
    is pir("    %r = bands %0, %1")
    { ... }

proto 'infix:~<' is equiv('infix:*') { ... }
proto 'infix:~>' is equiv('infix:*') { ... }


## additive
proto 'infix:+' is precedence('16=')
    is post('add')
    is pirop('n_add')
    { ... }

proto 'infix:-' is equiv('infix:+')
    is post('sub')
    { ... }

proto 'infix:~' is equiv('infix:+')
    is post('concat')
    is returns('Str')
    { ... }

proto 'infix:+|' is equiv('infix:+')
    is post('bor')
    { ... }

proto 'infix:+^' is equiv('infix:+')
    is post('bxor')
    { ... }

proto 'infix:~|' is equiv('infix:+')
    is post('bors')
    { ... }

proto 'infix:~^' is equiv('infix:+')
    is post('bxors')
    { ... }

proto 'infix:?|' is equiv('infix:+') { ... }
proto 'infix:?^' is equiv('infix:+') { ... }


## junctive and (all)
proto 'infix:&' is precedence('15=') { ... }


## junctive or (any)
proto 'infix:|' is precedence('14=') { ... }
proto 'infix:^' is equiv('infix:|') { ... }


## named unary
proto 'prefix:rand' is precedence('13=')
    is nullterm
    { ... }

proto 'prefix:sleep' is equiv('prefix:rand')
    is nullterm
    { ... }

proto 'prefix:abs' is equiv('prefix:rand')
    is nullterm
    is post('abs')
    { ... }

proto 'prefix:-w' is equiv('prefix:rand') is nullterm { ... }
proto 'prefix:-r' is equiv('prefix:rand') is nullterm { ... }
proto 'prefix:-x' is equiv('prefix:rand') is nullterm { ... }
proto 'prefix:-e' is equiv('prefix:rand') is nullterm { ... }
proto 'prefix:-z' is equiv('prefix:rand') is nullterm { ... }
proto 'prefix:-s' is equiv('prefix:rand') is nullterm { ... }
proto 'prefix:-f' is equiv('prefix:rand') is nullterm { ... }
proto 'prefix:-d' is equiv('prefix:rand') is nullterm { ... }


## nonchaining binary
proto 'infix:<=>' is precedence('12=') is assoc('non') { ... }
proto 'infix:cmp' is equiv('infix:<=>') { ... }
proto 'infix:is' is equiv('infix:<=>') { ... }
proto 'infix:but' is equiv('infix:<=>') { ... }
proto 'infix:does' is equiv('infix:<=>') { ... }
proto 'infix:..' is equiv('infix:<=>') { ... }
proto 'infix:^..' is equiv('infix:<=>') { ... }
proto 'infix:..^' is equiv('infix:<=>') { ... }
proto 'infix:^..^' is equiv('infix:<=>') { ... }
proto 'infix:ff' is equiv('infix:<=>') { ... }
proto 'infix:^ff' is equiv('infix:<=>') { ... }
proto 'infix:ff^' is equiv('infix:<=>') { ... }
proto 'infix:^ff^' is equiv('infix:<=>') { ... }
proto 'infix:fff' is equiv('infix:<=>') { ... }
proto 'infix:^fff' is equiv('infix:<=>') { ... }
proto 'infix:fff^' is equiv('infix:<=>') { ... }
proto 'infix:^fff^' is equiv('infix:<=>') { ... }


## chaining binary
proto 'infix:==' is precedence('11=') is assoc('chain')
    is pasttype('chain')
    { ... }

proto 'infix:!=' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:<' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:<=' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:>' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:>=' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:~~' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:!~' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:=~' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:eq' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:ne' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:lt' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:le' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:gt' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:ge' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:=:=' is equiv('infix:==')
    is pasttype('chain')
    { ... }

proto 'infix:===' is equiv('infix:==')
    is pasttype('chain')
    { ... }


## tight and
proto 'infix:&&' is precedence('10=')
    is pasttype('cond') 
    { ... }


## tight or
proto 'infix:||' is precedence('09=')
    is pasttype('cond') 
    { ... }

proto 'infix:^^' is precedence('09=') is assoc('list')
    is pasttype('xor') 
    { ... }

proto 'infix://' is equiv('infix:||') 
    is pasttype('cond') 
    { ... }


## ternary
proto 'ternary:?? !!' is precedence('08=') is assoc('right')
    is pasttype('cond') 
    { ... }


## assignment
proto 'infix:=' is precedence('07=') is assoc('right')
    is pasttype('assign') 
    { ... }

proto 'infix::=' is equiv('infix:=') { ... }
proto 'infix:::=' is equiv('infix:=') { ... }
proto 'infix:.=' is equiv('infix:=') { ... }
proto 'infix:~=' is equiv('infix:=') { ... }
proto 'infix:+=' is equiv('infix:=') { ... }
proto 'infix:-=' is equiv('infix:=') { ... }
proto 'infix:*=' is equiv('infix:=') { ... }
proto 'infix:/=' is equiv('infix:=') { ... }
proto 'infix:%=' is equiv('infix:=') { ... }
proto 'infix:x=' is equiv('infix:=') { ... }
proto 'infix:Y=' is equiv('infix:=') { ... }
proto 'infix:**=' is equiv('infix:=') { ... }
proto 'infix:xx=' is equiv('infix:=') { ... }
proto 'infix:||=' is equiv('infix:=') { ... }
proto 'infix:&&=' is equiv('infix:=') { ... }
proto 'infix://=' is equiv('infix:=') { ... }
proto 'infix:^^=' is equiv('infix:=') { ... }
proto 'infix:+<=' is equiv('infix:=') { ... }
proto 'infix:+>=' is equiv('infix:=') { ... }
proto 'infix:+|=' is equiv('infix:=') { ... }
proto 'infix:+&=' is equiv('infix:=') { ... }
proto 'infix:+^=' is equiv('infix:=') { ... }
proto 'infix:~|=' is equiv('infix:=') { ... }
proto 'infix:~&=' is equiv('infix:=') { ... }
proto 'infix:~^=' is equiv('infix:=') { ... }
proto 'infix:?|=' is equiv('infix:=') { ... }
proto 'infix:?&=' is equiv('infix:=') { ... }
proto 'infix:?^=' is equiv('infix:=') { ... }
proto 'infix:|=' is equiv('infix:=') { ... }
proto 'infix:&=' is equiv('infix:=') { ... }
proto 'infix:^=' is equiv('infix:=') { ... }


## list item separator
proto 'infix:,' is precedence('06=') is assoc('list')
   is nullterm { ... }
## TODO zip


## listop
proto 'infix:<==' is precedence('05=') is assoc('right') { ... }
proto 'prefix:true' is equiv('infix:<==') { ... }
proto 'prefix:not' is equiv('infix:<==') { ... }

## TODO print push any all 
##    XXX: do these really belong here? ~particle
##    XXX: I think they're really sub calls, so no.  ~pmichaud


## pipe forward
proto 'infix:==>' is precedence('04=') { ... }


## loose and
proto 'infix:and' is precedence('03=')
    is pasttype('cond') 
    { ... }


## loose or
proto 'infix:or' is precedence('02=')
    is pasttype('cond') 
    { ... }

proto 'infix:xor' is equiv('infix:or')
    is pasttype('xor') 
    { ... }

proto 'infix:err' is equiv('infix:or') 
    is pasttype('cond')
    { ... }


## expression terminator
proto 'infix:;' is precedence('01=') is assoc('list')
    is nullterm
    is post('set')
    { ... }


## statement control
##    XXX: This isn't really being used for parsing in the 
##    expression parser, but is here as a convenient means
##    of setting the pasttype trait for if/unless statements
##    and modifiers.
proto 'statement_control:if' is pasttype('cond') { ... }


## vim: expandtab sw=4
