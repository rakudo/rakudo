## $Id$

## TITLE
##     The Perl 6 grammar
##
## DESCRIPTION
##
## These are the regexes used to compile Perl 6 programs.
## This is just a first draft of a grammar for parsing
## Perl 6 programs, undoubtedly more regexes will be added
## soon.  Much of the work is hidden in the <opparse>
## regex, which is defined in L<Perl6/parse.pir>
## and handles most expressions using a bottom-up
## parsing algorithm.

grammar Perl6::Grammar ;


## These regexes handle whitespace between comments and tokens

token ws {
    [ \s+
    | ^^ [ \# \N*
         | <?pod_comment>
         ]
    | \# [ <?PGE::Text::bracketed: <({[>
         | \N*
         ]
    ]*
}

regex pod_comment {
    ^^ = [ [ cut \h*: | end [\h\N*]? ]
         | for [ \h\N+: ] \n [ \N+\n ]*:
         | \w\N*: \n .*? \n = [ cut \h*: | end [\h\N*:]? ]
         ]
         [\n|$]
}


token program { 
    ^ <statement_list> <?ws> [ $ | <?syntax_error> ] 
}


token statement_list { 
    <statement> [ <?statement_end> <statement> ]* <?statement_end>? 
}


token statement_end {
      [ <?ws> ; ]+ 
    | <after \}> :: \h* [ \#\N* ]? \n 
}


## XXX: <statement_control> will likely become <%statement_control>.
## Since PGE doesn't support hashes in regexes yet, we're just using
## an alternation for now.  
##
## The subrule C<< <expression:  ;> >> calls the C<expression> sub 
## in L<src/parse.pir>, which passes control to the operator
## precedence parser.  The space+semicolon parameter tells
## the operator precedence parser to stop parsing the expression
## at any top-level semicolon (with optional leading <?ws>).
## (This may yet change as we refine things further.)

token statement {
    <statement_control>
    | <block>
    | <expression:  ;> <statement_modifier>?  
}


## Here, the <expression> subrule doesn't parse any top-level
## bare closures (controlled by the space+brace argument).
token statement_control {
    <?ws>:
    $<KEY>:=[if|unless] <expression:  {> <block>
        [ <?ws>: elsif <expression:  {> <block> ]*
        [ <?ws>: else <block> ]?
}


token statement_modifier {
    <?ws> $<KEY>:=[if|unless] <expression:  ;>
}


token block {
    <?ws>:
    \{
        <?ws>: <statement_list> <?ws>:
    [ \} | <?syntax_error> ]
}


## We handle Perl 6 expressions using PGE's operator
## precedence parser.  The tokens and sub for this are
## defined in L<Perl6/parser.pir>.  If written as a p6regex,
## it would look something like:
##     regex expression($stop) { { $opparse.parse($/, $stop) } }

## The <term> regex gets called from the operator precedence
## parser whenever it needs a term.

token term {
    [ <scoped_variables>
    | <variable>
    | <subroutine>
    | <block>
    | <regex_term>
    | <number>
    | <integer>
    | <string_literal>
    | <version>
    | <listop> [ <postop> | <listop_expression> ]? 
    | <circumfix>
    ] <postop>*
}


token postop { <?dot>? [ <postfix> | <postcircumfix> ] }
## XXX: Eventually this will likely read <%postfix | %postcircumfix>.
## And we may have to deal with precedence issues somewhere.

token dot { \. | [ \\ <?ws> ]? \. }

token postfix { $<KEY>:=[\+\+|--] }

token postcircumfix {
    [ $<KEY>:=[\(] <?ws> <expression> <?ws> $<KEY_CLOSE>:=[\)]
    | $<KEY>:=[\[] <?ws> <expression> <?ws> $<KEY_CLOSE>:=[\]]
    ]
}

token circumfix {
    [ $<KEY>:=[\(] <?ws> <expression> <?ws> $<KEY_CLOSE>:=[\)]
    | $<KEY>:=[\[] <?ws> <expression> <?ws> $<KEY_CLOSE>:=[\]]
    ]
}

## The <listop> rule matches a list operator and its list arguments,
## if any.  Currently <reserved_word> is here as a protective measure, 
## eventually it should be taken out.

token listop { <reserved_word> ::: <fail> | <ident> }
token reserved_word { [ if | unless | while | until | for | loop ] \b }

## This is a temporary rule that allows parsing of /regex/
## in term position.  XXX: It is likely to change.

token regex_term { / <regex: /> / }

rule scoped_variables {
    <scope_declarator> <variable>
}
token scope_declarator { [ my | our ] }


## XXX: These are just placeholder regexes for demonstration,
## they certainly need to be expanded to be more complete.

token variable { \$/ | \$_ | <sigil> <name> }
token sigil { <[$@%^&]> }

token integer {
      0 [ b <[01]>+           [ _ <[01]>+ ]*
        | o <[0..7]>+         [ _ <[0..7]>+ ]*
        | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
        | d \d+               [ _ \d+]* 
        ]
    | \d+[_\d+]*
}

token number {
    \d+[_\d+]* [ \. \d+[_\d+]* [ <[Ee]> <[+\-]>? \d+ ]? ]
}

##  XXX: arguments to quoted_literal are a cheat for the time being.
token string_literal {
      " <quoted_literal: "> "
    | ' <quoted_literal: '> '
}

token version { v\d+ }


## Subroutine parsing.  This is still under development.

rule subroutine {
    [<scope_declarator> <type>?]?
        <subintro>
        <ident>?
        <trait>*
        [\( <signature> \)]?
        <block>}

rule subintro { <routine_modifier> <routine_type>? | <routine_type> }

token routine_modifier { multi | proto }

token routine_type { sub | method | submethod | macro }

token type { <routine_type> ::: <fail> | <ident> }

rule trait {
      $<KEY>:=[is] <ident>[\( <expression> \)]?
    | $<KEY>:=[will] <ident> <block>
    | $<KEY>:=[of] <type>
    | $<KEY>:=[returns] <type>
}

rule signature { 
    $<invocants>:=(<parameter> [, <parameter>]*)
    $<paramlist>:=(\: <parameter>? [, <parameter>]*)?
}

##  XXX: <parameter> needs expansion for the various
##  parameter options available.

token parameter { <sigil> <ident> }


## The <syntax_error> token generates a simple syntax
## error message, and displays the line number and context
## of the error.

token syntax_error { <?PGE::Util::die: Syntax error> }

## vim: expandtab sw=4
